Implementation Approach
The main goal of this assignment was to figure out if the parentheses in a given expression are balanced using a stack. A stack is perfect for this task because of its Last-In-First-Out (LIFO) structure. By adding every opening parenthesis ('(', '{', '[') to the stack and removing from the stack for every closing parenthesis (')', '}', ']'), we can make sure that each closing parenthesis has a matching opening one. This way, we can track whether the parentheses are correctly paired and ordered.

The logic behind the 'isBalanced' method involves going through each character in the expression. If we find an opening parenthesis, we add it to the stack. When we come across a closing parenthesis, we check if there's a corresponding opening one on top of the stack. If the stack is empty or the types of parentheses don't match, the method returns 'false', meaning the expression is unbalanced. The expression is considered balanced if the stack is empty after we've checked all the characters.

Challenges
One of the main challenges in this assignment was dealing with edge cases. For example, an expression without any parentheses or an empty string should still be considered balanced. Additionally, I had to ensure the efficiency of the algorithm, as the stack operations (adding and removing elements) have a time complexity of O(1). It was important to make sure that the method correctly handles different types of parentheses ('()', '{}', '[]') and identifies mismatches, especially when the expression contains various combinations of brackets. Another tricky part was managing the stack correctly, especially in cases where there were more closing brackets than opening ones or mismatched pairs. In these situations, it was necessary to return 'false' immediately to avoid unnecessary stack operations and keep the method efficient.

Unit Testing
Unit testing was crucial for making sure that the 'isBalanced' method worked correctly. By writing tests for different scenarios—such as expressions with one type of bracket, mixed types of brackets, balanced and unbalanced expressions, and edge cases like an empty string—I was able to ensure that the method could handle all possible inputs as expected. These tests helped catch any potential mistakes and confirmed that the logic was correct. Additionally, writing the tests before the code allowed me to follow a test-driven development approach, ensuring that the code met the requirements from the start.
